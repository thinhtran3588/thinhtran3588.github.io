[ { "title": "What I&#39;ve learned from Technical Analysis (Last updated at 2021-06-13)", "url": "/posts/what-i-ve-learned-from-technical-analysis.md/", "categories": "Trading", "tags": "", "date": "2021-06-13 13:03:00 +0700", "snippet": "I invested in Bitcoin a few years ago, but I have never taken it seriously. As a trivial result, I‚Äôve lost almost all of my investment. It‚Äôs just a small amount of money, and I have no problem losing it. However, when I started saving money for investment, I knew that I couldn‚Äôt continue investing without any knowledge as before. I started studied little by little from posts on websites, Facebook, forums, and books. The most valuable resource to me so far is Technical Analysis - The complete resourcefor financial market technicians, Second Edition. Most of knowledge here comes from that book.I write this post to note the most important Technical Analysis knowledge to me for future references and for anyone interested in it.Technical analysisTechnical analysis is used to determine the trend, when it is changing, when it has changed, when to enter a position (buy low), when to exit a position (sell high), and when the analysis is wrong and the position must be closed (stop loss).Assumptions Market has trend and it‚Äôs nonrandom. Price is determined by the interaction of supply and demand. As basic economic theory teaches, when demand increases, price goes up, and when demand decreases, price goes down. One of the factors that determine supply and demand is buyer and seller expectations. The Averages discount everything. ‚Äúprices fully reflect all available information.‚Äù (Eugene Fama‚Äôs,1970) History, in principle, will repeat itself (or as Mark Twain said, ‚ÄúHistory rhymes: It does not repeat‚Äù), and that humans will behave similarly to how they have in the past in similar circumstances. Trend lines and patterns are fractal. Each investor or trader has a specific time frame in which he or she operates. Interestingly, regardless of period, patterns occur with very similar, though not identical, shapes and characteristicsTrendThere are 3 types of trend: A rising trend, or uptrend: occurs when prices reach higher peaks and higher troughs. A declining trend, or downtrend, is the opposite‚Äîwhen prices reach lower troughs and lower peaks. A sideways or flat trend occurs when prices trade in a range without significant underlying upward or downward movement.MarketsMarkets are simply meeting places of buyers and sellers. Markets can be categorized in many ways. By dividing markets into categories based on how organized or integrated the market is, we have four different types of markets: direct search markets, brokered markets, dealer markets, and auction markets. We will only focus on the last one auction markets, where all participants converge at one place to buy or sell a good. The centralized facility can be a location, a clearinghouse, or even a computer. An important aspect of the auction market is that all information about offers and bids is centralized where it is readily accessible to all buyers and sellers. As all of the market participants converge, buyers and sellers need not search for each other, and a mutually agreeable price can be established, eliminating the bid-ask spread. The New York Stock Exchange is an example of a continuous auction market. Some auction markets can be studied using technical analysis, while others cannot. Exchange-traded fund (ETF) A security replicates an index fund or a basket of assets has become extremely popular as a trading and a hedging vehicle. ETFs hold assets, similar to a mutual fund. In most cases, ETFs distribute dividends (or reinvest them), thus eliminating the dividend spread seen in the index futures and options markets. Derivative Markets The term derivative describes a financial contract that ‚Äúderives‚Äù its value from some other investment vehicle, often called the underlying. The primary use for derivatives is to hedge against risk of loss in the underlying or to speculate with high leverage. Futures Markets Futures contracts that are traded in the futures markets are contracts in which the buyer and seller agree to trade at specific terms at a specific future date. Futures, unlike stocks, are contracts and represent an agreement to purchase or sell a very specific amount and quality of asset at the expiration date. Option Markets An option contract gives the holder the right, but not the obligation, to complete the transaction stated in the contract before the expiration date of the contract. There are two basic types of options‚Äîcall options and put options. The call option gives the owner the option to buy an asset at a particular price, known as the strike price, before the option expiration date. The owner of a put option has the right to sell the stated asset at the strike price before the option expiration date. Market players There are 3 types of market players: Informed players (professional or smart money investors) are professional speculators, position traders, hedge fund managers, professional arbitrageurs, and insiders. Uninformed (noise) players are the uninformed market participants are the noise players. A more widespread and older term is the public. Most mutual fund managers, pension fund managers, traders, and technical analysts are considered also to be in this category, even if they are professionals. Liquidity players are market participants who affect prices in the markets for other reasons than investment or trading. How is the market measured? As more of the market players want to buy stocks and fewer want to sell their stock holdings, stock prices will be driven up. Likewise, if many market players want to sell their stocks relative to the number of participants who want to buy stocks, stock prices will fall. Looking at the increase or decrease in the price of one stock will tell us how strong the market for that one particular stock is. If we want to measure the overall direction of the stock market, however, we need a way of measuring the movement of the broad market that is composed of the stocks of many companies: Price-Weighted Average, Market Capitalization Weighted Average, Equally Weighted (or Geometric) Average. Dow theoryCharles Dow, the father of modern technical analysis, was the first to create an index that measures the overall price movement of U.S. stocks. However, he never specifically formulated what has become known as the ‚ÄúDow Theory.‚Äù Indeed, he likely never intended his disjointed statements and observations in the Wall Street Journal to become formalized.Three hypotheses are presented by Robert Rhea, who wrote a book called The Dow Theory: An Explanation of Its Development and an Attempt to Define Its Usefulness as an Aid to Speculation in 1932: While the secondary and the minor, day-to-day motion of the stock market averages could possibly be manipulated, the primary trend is inviolate. The averages discount everything. Dow Theory is not infallible.Dow theory theorem The ideal market picture consists of an uptrend, top, downtrend, and bottom, interspersed with retracements and consolidations. Economic rationale should be used to explain stock market action. Prices trend. A trend is defined as the general direction in which something tends to move.There are three basic trends in price motion, each defined by time: The Primary Trend: the longest of the three trend types. It represents the overall, broad, long-term movement of security prices. The duration of this long-term trend can be several years. The primary trend may be an upward trend, which is known as a primary bull trend, or it may be a downward trend, referred to as a primary ‚Äúbear‚Äù trend. Primary bull markets are characterized by three separate phases: The first represents reviving confidence from the prior primary bear market; the second phase represents the response to increased corporate earnings; and the third is when speculation becomes dominant and prices rise on ‚Äúhopes and expectations.‚Äù Primary bear markets are long downward price movements, interrupted by occasional rallies, that continue until prices have discounted the worst that is apt to occur. They, too, are characterized by three separate phases: first, abandonment of hopes upon which stocks were purchased; second, selling due to decreased earnings; and third, distress selling, regardless of value, by those who believe the worst is yet to come or who are forced to liquidate. The Secondary Trend: an intermediate-term trend that runs counter to the primary trend. For example, during a several-year primary uptrend, prices may fall for a few weeks or a few months. During this secondary trend market decline, prices fall often, erasing 33% to 66% of the gain that has occurred since the completion of the previous secondary uptrend. Being able to anticipate or recognize secondary reactions increases profit capabilities by taking advantage of smaller market swings, but Dow believed this exercise was too dangerous. Because the primary trend and secondary trend reversal have similar characteristics, secondary reactions are often initially assumed as changes in primary trends or are mistakenly thought to be only reactions when the primary trend is changing. The Minor Trend: Daily fluctuations correspond to chaotic daily market movements which may last from a couple of hours to several days. These fluctuations are chaotic and thus they are unpredictable. Confirmation: The Dow Theory aims to signal changes in the primary market direction, and in order to achieve that mission, it uses two popular stock-market averages, DJIA (Dow Jones Industrial) and DJTA (Dow Jones Transportation). If one of these two indices changes its master trend, then this movement is evaluated as a secondary trend. If both indices change their master trend, then the master trend of the market is considered as changed. Obviously, we need to use other averages. There are many methods that can be used in order to distinguish a Bull from a Bear market. For example, many analysts use the 200-day Moving Average. If the market is above its 200-day MA then it is considered bullish, and if it trades below its 200-day MA it is considered bearish. Numerous other methods can be applied.Importance of Volume: Although volume of transactions cannot signal a trend reversal, it is important as a secondary confirmation of trend. Excessively high market prices that are accompanied by less volume on rallies and more activity on declines usually suggest an overbought market. Conversely, extremely low prices with dull declines and increased volume on rallies suggest an oversold market. ‚ÄúBull markets terminate in a period of excessive activity and begin with comparatively light transactions‚Äù (Rhea, 1932). The originators of Dow Theory were quick, however, not to overstate the importance of volume. Although volume was considered, it was not a primary consideration. Price trend and confirmation overrode any consideration of volume.References Technical Analysis - The complete resourcefor financial market technicians, Second Edition The Dow Theory(To be updated in the future)" }, { "title": "Work with Postgres in Nodejs using @tqt/pg-extensions", "url": "/posts/work-with-postgres-in-nodejs-using-tqt-pg-extensions/", "categories": "Tutorials", "tags": "postgres, nodejs, npm", "date": "2021-06-09 12:20:00 +0700", "snippet": "To work with Postgres in Nodejs, we can use an ORM tool (like sequelize) or interact directly with databases using queries and node-postgres. I prefer the second way since it maximize the performance and I can optimize my query without doing any magic trick. However, for CRUD operations, writing repetitive queries is not a good choice. One more hassle is that the pg package doesn‚Äôt support named parameters. So I write a new package which extends the original Pool from pg to solve my problems and may solve yours as well. Additional features in the extended pool: additional functions to support CRUD. support named parameters. support logging. Installationyarn add @tqt/pg-extensionsDocumentation 1. With Promise Initialize pool Query Count Get by id Create Update Remove Execute transaction 2. With Observable Initialize pool Query Count Get by id Create Update Remove Execute transaction With PromiseInitialize pool (Promise)import { Pool } from &quot;@tqt/pg-extensions&quot;;const pool = new Pool({ host: process.env.POSTGRES_HOST, port: +process.env.POSTGRES_PORT, database: process.env.POSTGRES_DB, user: process.env.POSTGRES_USER, password: process.env.POSTGRES_PASSWORD, ssl: Boolean(process.env.POSTGRES_SSL), // new option, optional log: ( message: | string | { queryText: string; params: unknown[] | undefined; duration: number } ) =&amp;gt; { console.log(message); // should log message or the query execution (only queries from extended functions are logged): // { // queryText: &quot;select * from app_user where id = $1&quot;, // params: [1], // duration: 100, --milliseconds // } },});pool.on(&quot;error&quot;, (err) =&amp;gt; console.log(err));pool.on(&quot;connect&quot;, () =&amp;gt; console.log(&quot;Connected to database&quot;));Query (Promise)Use this function instead of the original pool.query function.const result = await pool.executeQuery({ queryText: &quot;select * from app_user&quot;, whereClause: &quot;createAt &amp;gt;= :createAtFrom&quot;, // optional fields: [&quot;id&quot;, &quot;username&quot;, &quot;createdAt&quot;], // optional limit: 10, // optional offset: 20, // optional // optional params: { createAtFrom: &quot;1624679104000&quot;, },});// Generated query// SELECT id as &quot;id&quot;,username as &quot;username&quot;,createdAt as &quot;createdAt&quot; FROM (select * from app_user) T WHERE createAt &amp;gt; $3 LIMIT $1 OFFSET $2// Params: [&#39;1617869191488&#39;];// result = [{id: &#39;1&#39;, username: &#39;admin&#39;, createdAt: 1617869191488}]You may query a table. It can use named parameters and resolve the problem camelCase property name in the query result.const result = await pool.executeQuery({ table: &quot;app_user&quot;, whereClause: &quot;createdAt &amp;gt;= :createdAt AND tsv @@ to_tsquery(:searchTerm)&quot;, // optional fields: [&quot;id&quot;, &quot;username&quot;, &quot;createdAt&quot;], // optional sortBy: [&quot;username|ASC&quot;, &quot;createdAt|DESC&quot;], // optional pageIndex: 2, // optional rowsPerPage: 5, // optional // optional params: { searchTerm: &quot;admin&quot;, createdAt: 1617869191488, },});// Generated query// SELECT id as &quot;id&quot;,username as &quot;username&quot;,createdAt as &quot;createdAt&quot; FROM app_user WHERE createdAt &amp;gt;= $4 AND tsv @@ to_tsquery($3) ORDER BY username ASC, createdAt DESC LIMIT $1 OFFSET $2// Params: [5, 10, &#39;admin&#39;, 1617869191488];// result = [{id: 1, username: &#39;admin&#39;, createdAt: 1617869191488}]Or use offset, limit options with the same result.const result = await pool.executeQuery({ table: &quot;app_user&quot;, whereClause: &quot;createdAt &amp;gt;= :createdAt AND tsv @@ to_tsquery(:searchTerm)&quot;, fields: [&quot;id&quot;, &quot;username&quot;, &quot;createdAt&quot;], sortBy: [&quot;username|ASC&quot;, &quot;createdAt|DESC&quot;], limit: 5, offset: 10, params: { searchTerm: &quot;admin&quot;, createdAt: 1617869191488, },});// Generated query// SELECT id as &quot;id&quot;,username as &quot;username&quot;,createdAt as &quot;createdAt&quot; FROM app_user WHERE createdAt &amp;gt;= $4 AND tsv @@ to_tsquery($3) ORDER BY username ASC, createdAt DESC LIMIT $1 OFFSET $2// Params: [5, 10, &#39;admin&#39;, 1617869191488];// result = [{id: 1, username: &#39;admin&#39;, createdAt: 1617869191488}]For a raw query containing multiple queries, commands, just useconst result = await pool.executeQuery({ queryText: ` DELETE FROM app_user where id = :id1; DELETE FROM app_user where id = :id2; `, params: { id1: &quot;1&quot;, id2: &quot;2&quot;, },});// Generated query// DELETE FROM app_user where id = $1;// DELETE FROM app_user where id = $2;// Params: [&#39;1&#39;, &#39;2&#39;];type executeQuery = &amp;lt;T&amp;gt;(query: DbQuery) =&amp;gt; Promise&amp;lt;T[]&amp;gt;;Count (Promise)Count the number of records. Use the same params as pool.executeQuery. Properties queryText, table, whereClause and params are only included when using table.const count = await pool.count({ queryText: &quot;select * from app_user where id = :id&quot;,});// Return the number of records// Generated query// SELECT COUNT(*) FROM (select * from app_user where id = $1) AS T// Params: [1]// count = 1const count = await pool.count({ table: &quot;app_user&quot;, whereClause: &quot;createdAt &amp;gt;= :createdAt AND tsv @@ to_tsquery(:searchTerm)&quot;, // optional fields: [&quot;id&quot;, &quot;username&quot;, &quot;createdAt&quot;], sortBy: [&quot;username|ASC&quot;, &quot;createdAt|DESC&quot;], pageIndex: 2, rowsPerPage: 5, params: { searchTerm: &quot;admin&quot;, createdAt: 1617869191488, },});// Return the number of records// Generated query// SELECT COUNT(*) FROM (SELECT * FROM app_user WHERE createdAt &amp;gt;= $2 AND tsv @@ to_tsquery($1)) AS T// Params: [&#39;admin&#39;, 1617869191488]// count = 1type count = (query: DbQuery) =&amp;gt; Promise&amp;lt;number&amp;gt;;Get by id (Promise)Get a record in a table using id.const entity = await pool.getById(&quot;app_user&quot;)(1, [&quot;id&quot;, &quot;username&quot;]);// Generated query// SELECT id as &quot;id&quot;,username as &quot;username&quot; FROM app_user WHERE id = $1// Params: [1]// entity = {// id: 1,// username: &#39;admin&#39;,// createdAt: 1617869191488// }const entity = await pool.getById(&quot;app_user&quot;)( 1, [&quot;userId&quot;, &quot;username&quot;, &quot;createdAt&quot;], &quot;userId&quot;);// in case the primary key column is named &#39;userId&#39;// Generated query// SELECT userId as &quot;userId&quot;,username as &quot;username&quot; FROM app_user WHERE userId = $1// Params: [1]// entity = {// userId: 1,// username: &#39;admin&#39;,// createdAt: 1617869191488// }type getById = ( table: string) =&amp;gt; &amp;lt;Record, Id&amp;gt;( id: Id, fields?: string[], idField?: string) =&amp;gt; Promise&amp;lt;Record | undefined&amp;gt;;Create (Promise)Create a new record in a specific table.const id = await pool.create(&quot;app_user&quot;)({ username: &quot;thinh&quot;, displayName: &quot;Thinh Tran&quot;,});// Generated query// INSERT INTO app_user(username,displayName) VALUES($1,$2) RETURNING id// Params: [&#39;thinh&#39;, &#39;Thinh Tran&#39;]// Return id from the new recordtype create = ( table: string) =&amp;gt; &amp;lt;Record, Id&amp;gt;(record: Partial&amp;lt;Record&amp;gt;) =&amp;gt; Promise&amp;lt;Id&amp;gt;;Update (Promise)Update an existing record in a specific table.await pool.update(&quot;app_user&quot;)(4, { username: &quot;thinh&quot;, displayName: &quot;Thinh Tran&quot;,});// Generated query// UPDATE app_user SET username=$2,displayName=$3 WHERE id = $1// Params: [4, &#39;thinh&#39;, &#39;Thinh Tran&#39;]// in case the primary key column is named &#39;userId&#39;await pool.update(&quot;app_user&quot;)( 4, { username: &quot;thinh&quot;, displayName: &quot;Thinh Tran&quot; }, &quot;userId&quot;);type update = ( table: string) =&amp;gt; &amp;lt;Record, Id&amp;gt;( id: Id, updatedData: Partial&amp;lt;Record&amp;gt;, idField?: string) =&amp;gt; Promise&amp;lt;void&amp;gt;;Remove (Promise)Remove a record in a specific table by id.await pool.remove(&quot;app_user&quot;)(4);// Generated query// DELETE FROM app_user WHERE id = $1// Params: [4]// in case the primary key column is named &#39;userId&#39;await pool.remove(&quot;app_user&quot;)(4, &quot;userId&quot;);type remove = ( table: string) =&amp;gt; &amp;lt;Record, Id&amp;gt;(id: Id, idField?: string) =&amp;gt; Promise&amp;lt;void&amp;gt;;Execute transaction (Promise)Run transaction. ExtendedPoolClient has similar extended functions like Pool. In case something wrong happens, the transaction is automatically rolled back.pool.executeTransaction(async (client) =&amp;gt; { await client.update(&quot;app_user&quot;)(4, { username: &quot;thinh&quot;, displayName: &quot;Thinh Tran&quot;, }); await client.update(&quot;app_user&quot;)(5, { username: &quot;test&quot;, displayName: &quot;Test&quot; });});type executeTransaction = ( transaction: (client: ExtendedPoolClient) =&amp;gt; Promise&amp;lt;void&amp;gt;) =&amp;gt; Promise&amp;lt;void&amp;gt;;With ObservableInitialize pool (Observable)Use this function instead of the original pool.query function.import { RxPool } from &quot;@tqt/pg-extensions&quot;;const pool = new RxPool({ host: process.env.POSTGRES_HOST, port: +process.env.POSTGRES_PORT, database: process.env.POSTGRES_DB, user: process.env.POSTGRES_USER, password: process.env.POSTGRES_PASSWORD, ssl: Boolean(process.env.POSTGRES_SSL), // new option, optional log: ( message: | string | { queryText: string; params: unknown[] | undefined; duration: number } ) =&amp;gt; { console.log(message); // should log message or the query execution (only queries from extended functions are logged): // { // queryText: &quot;select * from app_user where id = $1&quot;, // params: [1], // duration: 100, --milliseconds // } },});pool.on(&quot;error&quot;, (err) =&amp;gt; console.log(err));pool.on(&quot;connect&quot;, () =&amp;gt; console.log(&quot;Connected to database&quot;));Query (Observable)Use this function instead of the original pool.query function.pool .executeQuery({ queryText: &quot;select * from app_user&quot;, whereClause: &quot;createAt &amp;gt;= :createAtFrom&quot;, // optional fields: [&quot;id&quot;, &quot;username&quot;, &quot;createdAt&quot;], // optional limit: 10, // optional offset: 20, // optional // optional params: { createAtFrom: &quot;1624679104000&quot;, }, }) .subscribe({ next: (result) =&amp;gt; { console.log(result); }, });// Generated query// SELECT id as &quot;id&quot;,username as &quot;username&quot;,createdAt as &quot;createdAt&quot; FROM (select * from app_user) T WHERE createAt &amp;gt; $3 LIMIT $1 OFFSET $2// Params: [&#39;1617869191488&#39;];// result = [{id: &#39;1&#39;, username: &#39;admin&#39;, createdAt: 1617869191488}]type executeQuery = &amp;lt;T&amp;gt;(query: DbQuery) =&amp;gt; Promise&amp;lt;T[]&amp;gt;;You may query a table. It can use named parameters and resolve the problem camelCase property name in the query result.pool .executeQuery({ table: &quot;app_user&quot;, whereClause: &quot;createdAt &amp;gt;= :createdAt AND tsv @@ to_tsquery(:searchTerm)&quot;, // optional fields: [&quot;id&quot;, &quot;username&quot;, &quot;createdAt&quot;], // optional sortBy: [&quot;username|ASC&quot;, &quot;createdAt|DESC&quot;], // optional pageIndex: 2, // optional rowsPerPage: 5, // optional // optional params: { searchTerm: &quot;admin&quot;, createdAt: 1617869191488, }, }) .subscribe({ next: (result) =&amp;gt; { console.log(result); }, });// Generated query// SELECT id as &quot;id&quot;,username as &quot;username&quot;,createdAt as &quot;createdAt&quot; FROM app_user WHERE createdAt &amp;gt;= $4 AND tsv @@ to_tsquery($3) ORDER BY username ASC, createdAt DESC LIMIT $1 OFFSET $2// Params: [5, 10, &#39;admin&#39;, 1617869191488];// result = [{id: 1, username: &#39;admin&#39;, createdAt: 1617869191488}]Or use offset, limit options with the same result.pool .executeQuery({ table: &quot;app_user&quot;, whereClause: &quot;createdAt &amp;gt;= :createdAt AND tsv @@ to_tsquery(:searchTerm)&quot;, fields: [&quot;id&quot;, &quot;username&quot;, &quot;createdAt&quot;], sortBy: [&quot;username|ASC&quot;, &quot;createdAt|DESC&quot;], limit: 5, offset: 10, params: { searchTerm: &quot;admin&quot;, createdAt: 1617869191488, }, }) .subscribe({ next: (result) =&amp;gt; { console.log(result); }, });// Generated query// SELECT id as &quot;id&quot;,username as &quot;username&quot;,createdAt as &quot;createdAt&quot; FROM app_user WHERE createdAt &amp;gt;= $4 AND tsv @@ to_tsquery($3) ORDER BY username ASC, createdAt DESC LIMIT $1 OFFSET $2// Params: [5, 10, &#39;admin&#39;, 1617869191488];// result = [{id: 1, username: &#39;admin&#39;, createdAt: 1617869191488}]For a raw query containing multiple queries, commands, just usepool .executeQuery({ queryText: ` DELETE FROM app_user where id = :id1; DELETE FROM app_user where id = :id2; `, params: { id1: &quot;1&quot;, id2: &quot;2&quot;, }, }) .subscribe({ next: () =&amp;gt; {}, });// Generated query// DELETE FROM app_user where id = $1;// DELETE FROM app_user where id = $2;// Params: [&#39;1&#39;, &#39;2&#39;];Count (Observable)Count the number of records. Use the same params as pool.executeQuery. Only properties queryText, table, whereClause and params are included when using table.pool .count({ queryText: &quot;select * from app_user where id = :id&quot;, }) .subscribe({ next: (count) =&amp;gt; { console.log(count); }, });// Return the number of records// Generated query// SELECT COUNT(*) FROM (select * from app_user where id = $1) AS T// Params: [1]// count = 1pool .count({ table: &quot;app_user&quot;, whereClause: &quot;createdAt &amp;gt;= :createdAt AND tsv @@ to_tsquery(:searchTerm)&quot;, // optional fields: [&quot;id&quot;, &quot;username&quot;, &quot;createdAt&quot;], sortBy: [&quot;username|ASC&quot;, &quot;createdAt|DESC&quot;], pageIndex: 2, rowsPerPage: 5, params: { searchTerm: &quot;admin&quot;, createdAt: 1617869191488, }, }) .subscribe({ next: (count) =&amp;gt; { console.log(count); }, });// Return the number of records// Generated query// SELECT COUNT(*) FROM (SELECT * FROM app_user WHERE createdAt &amp;gt;= $2 AND tsv @@ to_tsquery($1)) AS T// Params: [&#39;admin&#39;, 1617869191488]// count = 1type count = (query: DbQuery) =&amp;gt; Promise&amp;lt;number&amp;gt;;Get by id (Observable)Get a record in a table using id.pool .getById(&quot;app_user&quot;)(1, [&quot;id&quot;, &quot;username&quot;]) .subscribe({ next: (entity) =&amp;gt; { console.log(count); }, });// Generated query// SELECT id as &quot;id&quot;,username as &quot;username&quot; FROM app_user WHERE id = $1// Params: [1]// entity = {// id: 1,// username: &#39;admin&#39;,// createdAt: 1617869191488// }pool .getById(&quot;app_user&quot;)(1, [&quot;userId&quot;, &quot;username&quot;, &quot;createdAt&quot;], &quot;userId&quot;) .subscribe({ next: (entity) =&amp;gt; { console.log(count); }, });// in case the primary key column is named &#39;userId&#39;// Generated query// SELECT userId as &quot;userId&quot;,username as &quot;username&quot; FROM app_user WHERE userId = $1// Params: [1]// entity = {// userId: 1,// username: &#39;admin&#39;,// createdAt: 1617869191488// }type getById = ( table: string) =&amp;gt; &amp;lt;Record, Id&amp;gt;( id: Id, fields?: string[], idField?: string) =&amp;gt; Promise&amp;lt;Record | undefined&amp;gt;;Create (Observable)Create a new record in a specific table.pool .create(&quot;app_user&quot;)({ username: &quot;thinh&quot;, displayName: &quot;Thinh Tran&quot; }) .subscribe({ next: (id) =&amp;gt; { console.log(id); }, });// Generated query// INSERT INTO app_user(username,displayName) VALUES($1,$2) RETURNING id// Params: [&#39;thinh&#39;, &#39;Thinh Tran&#39;]// Return id from the new recordtype create = ( table: string) =&amp;gt; &amp;lt;Record, Id&amp;gt;(record: Partial&amp;lt;Record&amp;gt;) =&amp;gt; Promise&amp;lt;Id&amp;gt;;Update (Observable)Update an existing record in a specific table.pool .update(&quot;app_user&quot;)(4, { username: &quot;thinh&quot;, displayName: &quot;Thinh Tran&quot; }) .subscribe({ next: () =&amp;gt; { console.log(&quot;done&quot;); }, });// Generated query// UPDATE app_user SET username=$2,displayName=$3 WHERE id = $1// Params: [4, &#39;thinh&#39;, &#39;Thinh Tran&#39;]// in case the primary key column is named &#39;userId&#39;pool .update(&quot;app_user&quot;)( 4, { username: &quot;thinh&quot;, displayName: &quot;Thinh Tran&quot; }, &quot;userId&quot; ) .subscribe({ next: () =&amp;gt; { console.log(&quot;done&quot;); }, });type update = ( table: string) =&amp;gt; &amp;lt;Record, Id&amp;gt;( id: Id, updatedData: Partial&amp;lt;Record&amp;gt;, idField?: string) =&amp;gt; Promise&amp;lt;void&amp;gt;;Remove (Observable)Remove a record in a specific table by id.pool .remove(&quot;app_user&quot;)(4) .subscribe({ next: () =&amp;gt; { console.log(&quot;done&quot;); }, });// Generated query// DELETE FROM app_user WHERE id = $1// Params: [4]// in case the primary key column is named &#39;userId&#39;pool .remove(&quot;app_user&quot;)(4, &quot;userId&quot;) .subscribe({ next: () =&amp;gt; { console.log(&quot;done&quot;); }, });type remove = ( table: string) =&amp;gt; &amp;lt;Record, Id&amp;gt;(id: Id, idField?: string) =&amp;gt; Promise&amp;lt;void&amp;gt;;Execute transaction (Observable)Run transaction. ExtendedPoolClient has the similar extended functions like Pool. In case something wrong happens, the transaction will automatically be rolled back.pool.executeTransaction(async (client) =&amp;gt; of({}).pipe( switchMap(() =&amp;gt; client.update(&quot;app_user&quot;)(4, { username: &quot;thinh&quot;, displayName: &quot;Thinh Tran&quot;, }) ), switchMap(() =&amp;gt; client.update(&quot;app_user&quot;)(5, { username: &quot;test&quot;, displayName: &quot;Test&quot; }) ), switchMap(() =&amp;gt; { // do nothing }) ));type executeTransaction = ( transaction: (client: ExtendedPoolClient) =&amp;gt; Promise&amp;lt;void&amp;gt;) =&amp;gt; Promise&amp;lt;void&amp;gt;;" }, { "title": "Migrate Postgres database", "url": "/posts/migrate-postgres-database/", "categories": "Tutorials", "tags": "postgres, nodejs", "date": "2021-05-30 06:26:00 +0700", "snippet": "I‚Äôve been working with SQL Server for years before moving to MongoDB. I loved Mongo for its simplicity but still wanted SQL so badly. People like SQL so much and even uses them in cloud services such as AWS Athena and Google Big Query. Then I decided to change to Postgres. I fell in love with it at first sight and want to work with it in the long term.One thing we all need when working with databases is managing schema. ORM (Object-Relational Mapping) tools do it so well with up/down features. We write code in some specific languages (C#, Javascript) and those tools to execute those scripts to update the database. I just want a simple tool having the similar feature but for SQL scripts so I‚Äôve written one by myself as an npm package: @tqt/pg-migrate.pg-migrate is a tool which manages databases‚Äô schema &amp;amp; data with SQL scripts.1. Use pg-migrate as a global commandnpm install -g @tqt/pg-migrateYou need to have a migration folder structured as below. You can name it whatever you want however its 2 sub-folders up and down are required. Put your main scripts in the up folder and name them in the alphabetical order (the order you want it to run). In case you want to downgrade, you need to place their counterparts in the down folder with the same name.- migration-folder - up - 001-add-sample-1.sql - 002-add-sample-2.sql - 003-add-sample-3.sql - down - 001-add-sample-1.sql - 002-add-sample-2.sql - 003-add-sample-3.sqlThen run the script with the up commandpg-migrate up --migration-folder your-migration-folder --host host-name --database database-name --port port --user user-name --password passwordFor examplepg-migrate up --migration-folder ./db-migration --host localhost --database sample --port 5432 --user postgres --password postgresAfter the command executes, a table named migration is created in your current database with all executed scripts. id version createdAt 0 001-add-sample-1 1622278220790 1 002-add-sample-2 1622279735989 2 003-add-sample-3 1622279766950 In case you want to migrate to a specific version but not the latest one, runpg-migrate up 002-add-sample-2 --migration-folder ./db-migration --host localhost --database sample --port 5432 --user postgres --password postgresTo downgrade to a specific version, run the script with the down commandpg-migrate down 002-add-sample-2 --migration-folder ./db-migration --host localhost --database sample --port 5432 --user postgres --password postgresInstead of using parameters, you can use environment variables. You also may use a connection string. Here is the list of all parameters: param alternative environment variable sample ‚Äìmigration-folder POSTGRES_MIGRATION_FOLDER ./db-migration ‚Äìhost POSTGRES_HOST localhost ‚Äìport POSTGRES_PORT 5432 ‚Äìdatabase POSTGRES_DATABASE postgres ‚Äìuser POSTGRES_USER user ‚Äìpassword POSTGRES_PASSWORD password ‚Äìssl POSTGRES_SSL true ‚ÄìconnectionString POSTGRES_CONNECTION_STRING postgresql://dbuser:secretpassword@database.server.com:3211/mydb 2. Use pg-migrate as a local commandInstall the package as a dep dependency in your projectnpm install --save-dev @tqt/pg-migrateor using yarnyarn add -D @tqt/pg-migrateThen runnpx pg-migrate up --migration-folder your-migration-folder --host host-name --database database-name --port port --user user-name --password password3: Run it in your codeInstall the package as a dep dependency in your projectnpm install --save-dev @tqt/pg-migrateor using yarnyarn add -D @tqt/pg-migrateThen import and run it in your codeimport { migrate } from &quot;@tqt/pg-migrate&quot;;migrate({ migrationFolder: &quot;./db-migration&quot;, mode: &quot;up&quot;, poolConfig: { host: &quot;host&quot;, database: &quot;database&quot;, port: 5432, user: &quot;user&quot;, password: &quot;password&quot;, ssl: true, },});" }, { "title": "Use Cloudflare proxy with Lambda", "url": "/posts/use-cloudflare-proxy-with-lambda/", "categories": "Tutorials", "tags": "cloudflare, aws", "date": "2021-05-28 13:15:00 +0700", "snippet": " Get the Origin Certificate from Cloudflare. Go to your domain management page on Cloudflare. Go to SSL/TLS, then change to the tab Origin Server. Click the button Create Certificate. You should use default options and add 2 host names: your-domain.com &amp;amp; *.your-domain.com. Choose Pem format and save the Origin Certificate and the private key. Click the button Ok to create the certificate. Import certificate into AWS and map it to a Lambda function. Import the above certificate into AWS Certificate Manager with the certificate and the private key. For certificate chain, get Cloudflare Origin CA ‚Äî RSA Root from this link. Setup a Lambda function and an API Gateway endpoint pointing to it at a specific stage (dev/prod). In API Gateway Console, go to Custom domain names, create a new domain name. For example, api.your-domain.com, use the above certificate. Then map it to the API with a specific stage. Check its API Gateway domain name at the tab Configurations. Configure Cloudflare Point the domain (api.your-domain.com) to the API Gateway domain name in the above step with a CNAME record, proxy enabled. Go to SSL/TLS, change SSL/TLS encryption mode to Full. Note: It may take a while before you are able to access the lambda function with the custom domain." }, { "title": "Developer guidelines (Last updated at 2021-09-20)", "url": "/posts/developer-guidelines/", "categories": "Tutorials", "tags": "", "date": "2021-05-28 08:14:00 +0700", "snippet": "The guidelines to develop applications focusing on Typescript, Nodejs, React, React Native, Postgres &amp;amp; AWS.Backend1. Use GraphQL with Express serverimport express from &quot;express&quot;;import helmet from &quot;helmet&quot;;import { ApolloServer } from &quot;apollo-server-express&quot;;import { log } from &quot;@core&quot;;import { configureServer } from &quot;./server.config&quot;;const { apolloServerConfig } = configureServer();const port = process.env.PORT || 3000;const server = express().use( helmet({ contentSecurityPolicy: process.env.NODE_ENV === &quot;production&quot; ? undefined : false, }));const apolloServer = new ApolloServer(apolloServerConfig);apolloServer.applyMiddleware({ app: server });server.listen({ port }, () =&amp;gt; log.info( `üöÄ Server ready at http://localhost:${port}${apolloServer.graphqlPath}` ));2. Use GraphQL with Lambdaimport { ApolloServer } from &quot;apollo-server-lambda&quot;;import { configureServer } from &quot;./server.config&quot;;const { apolloServerConfig } = configureServer();const server = new ApolloServer(apolloServerConfig);exports.graphqlHandler = server.createHandler({ cors: { origin: true, credentials: true, },});Use this Serverless template to deploy a Lambda function.Follow instructions from this link.3. Optimized Docker file sampleUse this Docker file template.4. Kubernetes deployment sampleUse this deployment template.Web1. Set up a new app with Nextjs, Typescript, Tailwind CSS Set up a new project with Nextjs &amp;amp; Typescript (follow this) yarn create next-app --typescript Install Eslint parser/rules/plugins: eslint-config-airbnb, plugin:@next/next/recommended, eslint-config-prettier, eslint-plugin-prettier, eslint-plugin-no-null. Check this sample: .eslintrc.js yarn add --dev @typescript-eslint/parser @typescript-eslint/eslint-plugin @next/eslint-plugin-next eslint-config-prettier eslint-plugin-prettier eslint-plugin-no-null eslint-plugin-no-inline-styles npx install-peerdeps --dev eslint-config-airbnb Install Prettier (a fixed version) yarn add --dev prettier@2.4.1 Install Jest &amp;amp; Cypress: Follow this sample Install TailwindCSS yarn add --dev tailwindcss@latest postcss@latest autoprefixer@latest npx tailwindcss init -p Add bundle analyzer yarn add @next/bundle-analyzer Then update next.config.js const withBundleAnalyzer = require(&quot;@next/bundle-analyzer&quot;)({ enabled: process.env.ANALYZE === &quot;true&quot;,});module.exports = withBundleAnalyzer({}); Add Rematch - state management library with react-redux, immer, redux-persist yarn add @rematch/core @rematch/immer @rematch/persist immer react-redux redux-persist Then follow the tutorial 2. Internationalized Routing by updating next.config.js// next.config.jsmodule.exports = { i18n: { locales: [&quot;en&quot;, &quot;vi&quot;], defaultLocale: &quot;en&quot;, domains: [], },};3. Make PWA with next-pwayarn add next-pwa4. Make icon with thisMobile1. App Store Screenshot RequirementsThe required device screenshots for app submission are: iPhone 12 Pro Max ¬∑ 6.7-inch iPhone 8 Plus ¬∑ 5.5-inch iPad Pro ¬∑ 12.9-inch (only if the app runs on iPad)AWS1. Make a dashboard to monitor apps2. Use Serverless framework to make Lambda functions and expose them with API Gateway To reduce Lambda code storage, delete old versions of Lambda with this Serverless plugin or follow this link.DepOps1. Use Cloudflare proxy with LambdaFollow this post.2. Run scripts with environment variables stored in .env filesset -o allexport;source conf-file;set +o allexportNpm1. Publish a typescript package to npmFollow this link.2. Creating a NodeJS command-line packageFollow this link.Coding conventions1. Typescript Use Typescript as the main language to develops applications for backend, frontend (web, mobile). Use babel to compile Typescript. Use the module resolver to simplify the require/import paths in your project tsconfig.json { &quot;compilerOptions&quot;: { &quot;paths&quot;: { &quot;@main/*&quot;: [&quot;src/modules/main/*&quot;], &quot;@core&quot;: [&quot;src/core&quot;], &quot;@test/*&quot;: [&quot;__tests__/*&quot;] } }} babel.config.js module.exports = { plugins: [ [ require.resolve(&quot;babel-plugin-module-resolver&quot;), { root: [&quot;./src/&quot;], alias: { &quot;@test&quot;: &quot;./__tests__&quot;, &quot;@core&quot;: &quot;./src/core&quot;, &quot;@main&quot;: &quot;./src/modules/main&quot;, }, }, ], ],}; .eslintrc.js module.exports = { root: true, parser: &quot;@typescript-eslint/parser&quot;, plugins: [&quot;@typescript-eslint&quot;, &quot;no-null&quot;], extends: [ &quot;eslint:recommended&quot;, &quot;plugin:@typescript-eslint/recommended&quot;, &quot;airbnb-base&quot;, &quot;prettier&quot;, ], rules: { &quot;import/no-unresolved&quot;: [ &quot;error&quot;, { ignore: [&quot;@test&quot;, &quot;@core&quot;, &quot;@main&quot;] }, ], },}; 2. EslintUse Eslint as the linter for Typescript. Use the below base files which have rules based on AirBnB‚Äôs rules, Prettier &amp;amp; some custom rules. Backend .eslintrc.js .eslintignore Web .eslintrc.js .eslintignore Mobile 3. Prettier Use a fixed version (for example: ‚Äú2.3.0‚Äù) Use those base files .prettierrc.js .prettierignore " }, { "title": "The start of something new", "url": "/posts/start-of-something-new/", "categories": "Blogs", "tags": "", "date": "2021-05-26 12:10:00 +0700", "snippet": "It‚Äôs been nearly 1.5 years since I started working remotely at home. Time flies and many things have changed so much. Luckily, my job isn‚Äôt affected by Covid. I don‚Äôt have to go to the company but stay all the time at home, choose the time I want to work (that‚Äôs great!), have more time for my kids (that‚Äôs great as well but sometimes a disaster T_T) and sometimes can take some side projects. The most important thing to me is that I can spend more time with my kids in their childhood, even those sometimes deadlines haunted me, and I couldn‚Äôt play with them. But just staying nearby is still much better than working overtime day by day in the office. Besides that, after ten years working in companies, extending social networks isn‚Äôt necessary to me anymore. So I would keep working remotely as long as I can.I wrote some blogs with WordPress, Facebook notes, and Medium but couldn‚Äôt keep the progress for a long time. But I still love writing: taking notes for what I want to use in the future, some tutorials which I can share with other developers, and some blogs about my life. So I looked for some tools and finally went with Jekyll and Github Pages. This time, it would be a project which lasts years, not just months." } ]
